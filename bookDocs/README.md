---

[GitHub Source book code](https://github.com/yfain/getts)

### Chapter 1

**tsc** - это транслятор (компилятор) ts в js

`npm install` --save-dev typescript

`tsc --init` - создает файл в проекте tsconfig.js

```json
{
    "compilerOptions": {
        "baseUrl": "src", // от куда брать файлы
        "outDir": "./dist", // куда компилировать файлы
        "noEmitOnError": true, // не компилировать если есть ошибка
        "target": "es5", // к какому стандарту компилировать
        "watch": true, // при закуске tsc будет отслеживать изменения в ts файлах и при изминении их перекомпилировать в js
        "allowJs": true, // разрешать js модули
        "checkJs": true, // проверять js модули
        "lib": ["dom", "es2015"], // Библиотеки добавлены, и tsc не будет ругаться на неизвестные API вроде console()
        "strictNullChecks": true // запрещающую присвоение null переменным с известными типами.
    }
}
```

#### Для VSCode необходимые плагины

-   **ESLint** — интегрирует линтер JavaScript и проверяет код на читаемость и обслуживаемость.
-   **Prettier** — обеспечивает устойчивый стиль, считывая код и переформатируя его согласно своим правилам.
-   **Path Intellisense** — автоматически подставляет пути файлов.

### Chapter 2

Когда вы объявляете переменную, то можете добавить двоеточие и аннотацию типа, чтобы указать тип этой переменной:

```ts
let firstName: string
let age: number

let name1 = "John Smith" // Объявляет и инициализирует переменную без явной аннотации типа
let name2: string = "John Smith" // Объявляет и инициализирует переменную с аннотацией типа
```

TypeScript предлагает следующие аннотации типов:

-   **string** — для текстовых данных;
-   **boolean** — для значений true/false;
-   **number** — для численных значений;
-   **symbol** — уникальное значение, создаваемое вызовом конструктора Symbol;
-   **any** — для переменных, способных содержать значения разных типов, которые могут быть вам неизвестны в момент написания кода;
-   **unknown** — аналог any, с которым нельзя производить никаких действий, не - утвердив или сузив его до более конкретного типа;
-   **never** — для представления невозможного кода;
-   **void** — отсутствие значения.

Как объявить функцию, возвращающую либо string, либо null (вертикальная черта представляет собой объединенный тип):

```ts
function getName(): string | null {
  ...
}
```

Следует избегать явных аннотаций типов там, где компилятор TypeScript сможет вывести их сам. Следующий фрагмент кода объявляет переменные age и yourTax.
В нем нет необходимости указывать типы этих переменных, поскольку компилятор TypeScript и так их выведет.

```ts
const age = 25 // Константа age не объявляет свой тип
function getTax(income: number): number {
    return income * 0.15
}
let yourTax = getTax(50000) // Переменная yourTax не объявляет свой тип

let name3: "John Smith" // TypeScript также позволяет использовать в качестве типов литералы. Строка объявляет переменную типа John Smith.
```

--strictNullChecks, запрещающую присвоение null переменным с известными типами.

```ts
let productId = 123
productId = null // ошибка компилятора
productId = undefined // ошибка компилятора
```

#### Типы в обьявлениях функций

Функции и функциональные выражения в TypeScript похожи на функции JavaScript, но позволяют вам явно объявлять типы их аргументов и возвращаемых значений.

```ts
function calcTax(state: string, income: number, dependents: number): number {
    if (state === "NY") {
        return income * 0.06 - dependents * 500
    } else if (state === "NJ") {
        return income * 0.05 - dependents * 300
    }
}
```

> Компилятор TypeScript не предупредит вас о том, что функция в листинге 2.5 написана плохо и может вернуть undefined, но синтаксис TypeScript позволяет вам предупредить читающего код человека, что функция в листинге 2.5 может вернуть не только число, но и значение undefined, если будет вызвана со штатом, отличным от Нью-Йорка или Нью-Джерси. Для объявления подобного случая использования вам следует изменить сигнатуру функции так:
> `function calcTax(state: string, income: number, dependents: number) : number | undefined`

#### 2.1.3. Объединенный тип

Объединения позволяют вам выражать значение, которое может состоять из нескольких типов. Вы можете объявлять пользовательский тип, основанный на двух или более существующих типах. Например, вы можете объявить переменную типа, который может принимать либо значение string, либо значение number (вертикальная черта означает объединение):

`let padding: string | number;`

#### 2.2. ОПРЕДЕЛЕНИЕ ПОЛЬЗОВАТЕЛЬСКИХ ТИПОВ

TypeScript позволяет вам создавать пользовательские типы с помощью ключевого слова type, объявлением класса или интерфейса либо объявлением enum. Мы начнем знакомство с ключевого слова type.

```ts
// Объявление псевдонимов типов Foot и Pound
type Foot = number
type Pound = number

// Объявление нового типа, использующего псевдонимы
type Patient = {
    name: string
    height: Foot
    weight: Pound
    age?: number // ? - указывает на не обязательность поля
}

// Объявление и инициализация свойств типа
const patient: Patient = {
    name: "Patient",
    height: 100,
    weight: 20,
}
```

#### 2.2.2. Использование классов в качестве пользовательских типов

```ts
// in js

"use strict"
class PersonJs {
    constructor(firstName, lastName) {
        this.firstName = firstName
        this.lastName = lastName
    }
}

const pJs = new PersonJs("Ololo", "atata")

// in ts
class Person {
    constructor(public firstName: string, public lastName: string, private age?: number) {}
}

const p = new Person("Ololo", "Atata")
```

> ### КАКОЕ КЛЮЧЕВОЕ СЛОВО ИСПОЛЬЗОВАТЬ: TYPE, INTERFACE ИЛИ CLASS?
>
> Мы показали вам, что пользовательский тип может быть объявлен с помощью ключевых слов type, class либо interface. Какое же из них > лучше всего использовать для объявления пользовательского типа Person?
>
> Если этот тип не нужен для инстанцирования объектов в среде выполнения, используйте interface или type. В противном случае > используйте class. Другими словами, используйте class для создания пользовательского типа, если он будет задействоваться в > качестве значения.
>
> Например, если вы объявите интерфейс Person и при этом у вас будет функция, получающая аргумент типа Person, то вы не сможете > применить к этому аргументу оператор instanceof:
>
> ```ts
> interface Person {
>     name: string
> }
> function getP(p: Person) {
>     if (p instanceof Person) {
>         // ошибка компиляции
>     }
> }
> ```
>
> Модуль проверки типов выдаст ошибку, что Person относится только к типу, но используется здесь как значение.
>
> Если вы объявляете пользовательский тип просто для дополнительной безопасности, предлагаемой модулем проверки типов в TypeScript, > используйте type или interface. Ни интерфейсы, ни типы, объявленные с ключевым словом type, не имеют представления в генерируемом > JavaScript-коде, что уменьшает размер кода среды выполнения (байтовый). Если же для объявления типов вы используете классы, то они > оставят свой след в итоговом JavaScript.
>
> Определение пользовательского типа с ключевым словом type предлагает те же возможности, что и interface, плюс некоторые > дополнительные. Например, вы не можете использовать типы, объявленные как интерфейсы, в объединениях или пересечениях. В главе 3 > вы также узнаете об условных типах, которые не могут быть объявлены с помощью интерфейсов.

#### 2.2.4. Структурная система типов против номинальной

Код не сообщает об ошибках, так как TypeScript использует структурную систему типов, и поскольку классы Person и Customer имеют одинаковую структуру, допустимо присваивать экземпляр одного класса переменной другого.

```ts
class Person2 {
    name: string
}
class Customer2 {
    name: string
}

const cust: Customer2 = new Person2()
```

Более того, вы можете использовать объектные литералы для создания объектов и присваивания их class-типизированным переменным или константам до тех пор, пока форма этих объектных литералов будет такой же. Следующий код скомпилируется без ошибок:

```ts
class Person {
    name: String
}
class Customer {
    name: String
}
const cust: Customer = { name: "Mary" }
const pers: Person = { name: "John" }
```

```ts
class Person {
    name: String
    age: number // Мы добавили это свойство
}
class Customer {
    name: String
}
const cust: Customer = new Person() // по-прежнему нет ошибок
```

По-прежнему никаких ошибок! TypeScript видит, что Person и Customer имеют одинаковую форму (что-то общее). Мы просто хотели использовать константу типа Customer (у которой есть свойство name), чтобы указать на объект типа Person, у которого также есть свойство name.

Person имел больше свойств, чем Customer, и код компилировался без ошибок. Скомпилируется ли код следующего листинга, если класс Customer будет иметь больше свойств, чем Person?

```ts
class Person {
    name: string
}
class Customer {
    name: string
    age: number
}
const cust: Customer = new Person() // Типы не совпадают
```

Код не скомпилируется, так как ссылочная переменная cust будет указывать на объект Person, который даже не выделит память для свойства age, и присваивание вроде cust.age = 29 окажется невозможным. В этом случае тип Person уже не может быть присвоен типу Customer.





66

74